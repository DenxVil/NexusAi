// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
// Nexus AI Telegram Bot Service - Simplified and Clean Interface

import TelegramBot, { Message, InlineKeyboardMarkup } from 'node-telegram-bot-api';
import { AIService } from './aiService';
import config from '../config';

const token = config.telegramBotToken;
const adminUID = config.telegramAdminUid;

interface UserData {
  id: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  messageCount: number;
  tokenCount: number;
  joinDate: Date;
  lastActive: Date;
  isBlocked: boolean;
}

interface ChatHistory {
  userId: number;
  messages: Array<{
    id: string;
    text: string;
    isUser: boolean;
    timestamp: Date;
  }>;
}

export class TelegramBotService {
  private bot: TelegramBot | null = null;
  private aiService: AIService;
  private activeUsers: Set<number> = new Set();
  private users: Map<number, UserData> = new Map();
  private chatHistories: Map<number, ChatHistory> = new Map();

  // Usage limits
  private readonly MAX_MESSAGES_PER_DAY = 50;
  private readonly MAX_TOKENS_PER_DAY = 10000;

  // Magic 8-ball responses
  private readonly magic8BallResponses = [
    "ğŸ”® It is certain", "ğŸ”® It is decidedly so", "ğŸ”® Without a doubt",
    "ğŸ”® Yes definitely", "ğŸ”® You may rely on it", "ğŸ”® As I see it, yes",
    "ğŸ”® Most likely", "ğŸ”® Outlook good", "ğŸ”® Yes", "ğŸ”® Signs point to yes",
    "ğŸ”® Reply hazy, try again", "ğŸ”® Ask again later", "ğŸ”® Better not tell you now",
    "ğŸ”® Cannot predict now", "ğŸ”® Concentrate and ask again",
    "ğŸ”® Don't count on it", "ğŸ”® My reply is no", "ğŸ”® My sources say no",
    "ğŸ”® Outlook not so good", "ğŸ”® Very doubtful"
  ];

  constructor(aiService: AIService) {
    this.aiService = aiService;
    
    if (!token) {
      console.error('Telegram bot token is not provided. Bot initialization failed.');
      return;
    }

    this.bot = new TelegramBot(token, { polling: true });
    this.initializeListeners();
    this.loadUserData();
  }

  private initializeListeners(): void {
    if (!this.bot) return;

    // Essential commands only - clean and simple interface
    this.bot.onText(/\/start/, (msg) => this.handleStart(msg));
    this.bot.onText(/\/help/, (msg) => this.handleHelp(msg));
    this.bot.onText(/\/info/, (msg) => this.handleInfo(msg));

    // Basic features
    this.bot.onText(/\/imagine (.+)/, (msg, match) => this.handleImagine(msg, match));
    this.bot.onText(/\/8ball (.+)/, (msg, match) => this.handleMagic8Ball(msg, match));
    this.bot.onText(/\/weather (.+)/, (msg, match) => this.handleWeather(msg, match));
    this.bot.onText(/\/calculate (.+)/, (msg, match) => this.handleCalculate(msg, match));
    this.bot.onText(/\/define (.+)/, (msg, match) => this.handleDefine(msg, match));

    // Admin commands (if needed)
    if (adminUID !== 0) {
      this.bot.onText(/\/admin_stats/, (msg) => this.handleAdminStats(msg));
      this.bot.onText(/\/admin_broadcast (.+)/, (msg, match) => this.handleAdminBroadcast(msg, match));
    }

    // Handle regular messages
    this.bot.on('message', (msg) => this.handleUserMessage(msg));

    // Handle callback queries for inline keyboards
    this.bot.on('callback_query', (query) => this.handleCallbackQuery(query));

    // Error handling
    this.bot.on('polling_error', (error) => console.error(`Polling error: ${error.message}`));
    this.bot.on('webhook_error', (error) => console.error(`Webhook error: ${error.message}`));

    console.log('ğŸ¤– Nexus AI Telegram bot initialized with clean, simple interface');
  }

  private async handleStart(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = msg.from;
    
    if (!user) return;

    // Initialize user data
    const isNewUser = !this.users.has(user.id);
    this.initializeUser(user.id, user);
    
    const welcomeMessage = `
ğŸŒŸ *Welcome to Nexus AI!* ğŸŒŸ

Your advanced AI assistant created by â—‰ÆŠÑ”Ğ¸Î½Î¹â„“

ğŸ”® *What can I do for you?*
â€¢ Answer questions intelligently
â€¢ Help with various tasks
â€¢ Provide information and analysis
â€¢ Chat naturally with AI

ğŸŒ *Try the full experience:*
${config.websiteUrl}

ğŸ’¬ Simply send me any message to start chatting!
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸŒ Visit Website', url: config.websiteUrl }
        ],
        [
          { text: 'ğŸ’¬ Start Chatting', callback_data: 'start_chat' },
          { text: 'â“ Help', callback_data: 'show_help' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, welcomeMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending welcome message:', error);
    }
  }

  private async handleHelp(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;

    const helpMessage = `
ğŸ†˜ *Nexus AI Commands* ğŸ†˜

*ğŸ¤– Basic Commands:*
â€¢ Just type anything - Chat with AI
â€¢ /start - Welcome & introduction
â€¢ /help - Show this help message
â€¢ /info - About Nexus AI

*ğŸ¨ Creative Features:*
â€¢ /imagine [prompt] - Generate AI images
â€¢ /8ball [question] - Magic 8-ball predictions

*ğŸ› ï¸ Utility Commands:*
â€¢ /weather [city] - Get weather forecast
â€¢ /calculate [expression] - Math calculations
â€¢ /define [word] - Dictionary definitions

ğŸŒ *Visit our website for the full experience:*
${config.websiteUrl}

ğŸ’¬ *Ready to chat?* Just send me any message!

*Created with love ğŸ©¶ by â—‰ÆŠÑ”Ğ¸Î½Î¹â„“*
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸŒ Visit Website', url: config.websiteUrl }
        ],
        [
          { text: 'ğŸ’¬ Start Chatting', callback_data: 'start_chat' },
          { text: 'ğŸ¨ Generate Image', callback_data: 'generate_image' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, helpMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending help message:', error);
    }
  }

  private async handleInfo(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const totalUsers = this.users.size;
    const activeUsers = this.activeUsers.size;

    const infoMessage = `
ğŸ”® *About Nexus AI* ğŸ”®

*ğŸ¤– Advanced AI Assistant*
Nexus AI is your intelligent companion powered by cutting-edge technology and created with love by â—‰ÆŠÑ”Ğ¸Î½Î¹â„“.

*âœ¨ Key Features:*
â€¢ Multi-provider AI intelligence
â€¢ Natural conversation abilities
â€¢ Creative content generation
â€¢ Real-time information access
â€¢ Clean, simple interface

*ğŸ“Š Platform Statistics:*
â€¢ ğŸ‘¥ Total Users: ${totalUsers}
â€¢ ğŸŸ¢ Active Users: ${activeUsers}
â€¢ ğŸš€ Version: 2.0 (Nexus AI)
â€¢ âš¡ Status: Online & Optimized

*ğŸŒ Full Experience:*
Visit our website for enhanced features:
${config.websiteUrl}

*ğŸ”’ Privacy & Security:*
Your conversations are handled securely with privacy-first design.

*ğŸ“ Need Help?*
Use /help for commands or visit our website for support.

---
**Created with love ğŸ©¶ by â—‰ÆŠÑ”Ğ¸Î½Î¹â„“**
_Nexus AI - Where intelligence meets simplicity_
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸŒ Visit Website', url: config.websiteUrl }
        ],
        [
          { text: 'ğŸ“‹ Commands', callback_data: 'show_help' },
          { text: 'ğŸ’¬ Start Chat', callback_data: 'start_chat' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, infoMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending info message:', error);
    }
  }

  private async handleImagine(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const prompt = match[1].trim();
    
    if (!prompt) {
      await this.bot.sendMessage(chatId, 'ğŸ¨ Please provide a description for the image you want to generate.\n\nExample: /imagine a beautiful sunset over mountains');
      return;
    }

    try {
      await this.bot.sendChatAction(chatId, 'upload_photo');
      await this.bot.sendMessage(chatId, `ğŸ¨ *Creating image...* 
"${prompt}"

This might take a moment...`, { parse_mode: 'Markdown' });

      // Simulate image generation with placeholder
      // In a real implementation, this would call DALL-E, Stable Diffusion, etc.
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      const imageUrl = `https://picsum.photos/1024/1024?random=${Date.now()}`;
      
      await this.bot.sendPhoto(chatId, imageUrl, {
        caption: `ğŸ¨ *Generated Image*\nğŸ“ Prompt: "${prompt}"\n\n_Powered by ShanxAi Image Generation_`,
        parse_mode: 'Markdown'
      });

      this.updateUserUsage(chatId, 0, 100); // 100 tokens for image generation
      
    } catch (error) {
      console.error('Error generating image:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I encountered an error while generating the image. Please try again later.');
    }
  }

  private async handlePersona(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const persona = match[1].trim();
    
    this.userPersonas.set(chatId, persona);
    
    const confirmMessage = `ğŸ­ *Personality Updated!*

I'll now respond as: *${persona}*

Try chatting with me to see the difference! You can change my personality anytime with /persona [new personality].

*Popular personas to try:*
â€¢ Friendly assistant
â€¢ Wise philosopher
â€¢ Creative writer
â€¢ Technical expert
â€¢ Comedian
â€¢ Motivational coach

_Let's chat with my new personality!_ ğŸ’¬`;

    try {
      await this.bot.sendMessage(chatId, confirmMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error setting persona:', error);
    }
  }

  private async handleSummarize(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const url = match[1].trim();
    
    try {
      await this.bot.sendChatAction(chatId, 'typing');
      await this.bot.sendMessage(chatId, `ğŸ“š *Analyzing content...*\nğŸ”— ${url}\n\nPlease wait...`, { parse_mode: 'Markdown' });

      // Simulate content analysis
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const summary = `ğŸ“š *Content Summary*

ğŸ”— **Source:** ${url}

ğŸ“ **Summary:**
This is a simulated summary of the provided URL. In a full implementation, this would:

â€¢ Extract text content from the webpage
â€¢ Analyze the main points and themes
â€¢ Provide a concise summary using AI
â€¢ Highlight key insights and takeaways

ğŸ¯ **Key Points:**
â€¢ Main topic analysis
â€¢ Important facts and figures
â€¢ Relevant conclusions
â€¢ Actionable insights

_For accurate summaries, please ensure the URL is accessible and contains readable content._

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»`;

      await this.bot.sendMessage(chatId, summary, { parse_mode: 'Markdown' });
      this.updateUserUsage(chatId, 0, 150); // 150 tokens for summarization
      
    } catch (error) {
      console.error('Error summarizing content:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t summarize that content. Please check the URL and try again.');
    }
  }

  private async handleMagic8Ball(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const question = match[1].trim();
    
    const response = this.magic8BallResponses[Math.floor(Math.random() * this.magic8BallResponses.length)];
    
    const replyMessage = `ğŸ± *Magic 8-Ball* ğŸ±

**Your Question:** "${question}"

**The Magic 8-Ball says:**
${response}

_Ask another question anytime!_ âœ¨`;

    try {
      await this.bot.sendMessage(chatId, replyMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error with magic 8-ball:', error);
    }
  }

  private async handleDaily(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const today = new Date().toDateString();
    
    // Check if user already got today's content
    const userDailyKey = `${chatId}_${today}`;
    if (this.dailyContent.has(userDailyKey)) {
      await this.bot.sendMessage(chatId, 'ğŸ“… You\'ve already received today\'s content! Come back tomorrow for fresh content. ğŸŒŸ');
      return;
    }

    const dailyFacts = [
      "ğŸ§  Your brain uses about 20% of your body's total energy.",
      "ğŸŒ A day on Venus is longer than its year.",
      "ğŸ™ Octopuses have three hearts and blue blood.",
      "ğŸ¯ Honey never spoils - archaeologists have found edible honey in ancient tombs.",
      "âš¡ Lightning strikes the Earth about 100 times every second.",
      "ğŸŒŸ There are more possible games of chess than atoms in the observable universe.",
      "ğŸ§ Penguins have knees, they're just hidden inside their bodies.",
      "ğŸµ Music can help plants grow faster and healthier."
    ];

    const motivationalQuotes = [
      "ğŸ’ª 'Success is not final, failure is not fatal: it is the courage to continue that counts.' - Winston Churchill",
      "ğŸŒŸ 'The only way to do great work is to love what you do.' - Steve Jobs",
      "ğŸš€ 'Innovation distinguishes between a leader and a follower.' - Steve Jobs",
      "ğŸ’¡ 'The future belongs to those who believe in the beauty of their dreams.' - Eleanor Roosevelt",
      "ğŸ¯ 'Don't watch the clock; do what it does. Keep going.' - Sam Levenson"
    ];

    const techTips = [
      "ğŸ’» Use Ctrl+Shift+T to reopen recently closed browser tabs",
      "ğŸ“± Put your phone in airplane mode for faster charging",
      "ğŸ”’ Use two-factor authentication for better security",
      "ğŸ§ Noise-canceling headphones can improve focus and productivity",
      "ğŸ“· The rule of thirds can dramatically improve your photos"
    ];

    const randomFact = dailyFacts[Math.floor(Math.random() * dailyFacts.length)];
    const randomQuote = motivationalQuotes[Math.floor(Math.random() * motivationalQuotes.length)];
    const randomTip = techTips[Math.floor(Math.random() * techTips.length)];

    const dailyMessage = `
ğŸ“… *Your Daily ShanxAi Card* ğŸ“…
*${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}*

ğŸ¯ **Daily Fact:**
${randomFact}

ğŸ’­ **Inspiration of the Day:**
${randomQuote}

ğŸ’¡ **Tech Tip:**
${randomTip}

ğŸŒŸ **Your Daily Challenge:**
Try learning something new today, no matter how small. Knowledge compounds over time!

_Come back tomorrow for fresh content!_ âœ¨

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
    `;

    try {
      await this.bot.sendMessage(chatId, dailyMessage, { parse_mode: 'Markdown' });
      this.dailyContent.set(userDailyKey, true);
    } catch (error) {
      console.error('Error sending daily content:', error);
    }
  }

  private async handleWeather(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const city = match[1].trim();
    
    try {
      await this.bot.sendChatAction(chatId, 'typing');
      
      // Simulate weather API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const temperatures = [15, 18, 22, 25, 28, 20, 16];
      const conditions = ['Sunny', 'Partly Cloudy', 'Cloudy', 'Rainy', 'Stormy'];
      const temp = temperatures[Math.floor(Math.random() * temperatures.length)];
      const condition = conditions[Math.floor(Math.random() * conditions.length)];
      
      const weatherMessage = `
ğŸŒ¤ï¸ *Weather Forecast* ğŸŒ¤ï¸

ğŸ“ **Location:** ${city}
ğŸŒ¡ï¸ **Temperature:** ${temp}Â°C
â˜ï¸ **Condition:** ${condition}
ğŸ’¨ **Wind:** 15 km/h
ğŸ’§ **Humidity:** 65%

ğŸ”® **7-Day Outlook:** Mixed conditions expected

_This is a simulated forecast. For real weather data, integration with weather APIs is needed._

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
      `;

      await this.bot.sendMessage(chatId, weatherMessage, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Error getting weather:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t get weather information right now. Please try again later.');
    }
  }

  private async handleCalculate(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const expression = match[1].trim();
    
    try {
      // Simple math evaluation (secure implementation would use a proper math parser)
      const sanitized = expression.replace(/[^0-9+\-*/().\s]/g, '');
      const result = eval(sanitized);
      
      const calculationMessage = `
ğŸ§® *Calculator Result* ğŸ§®

**Expression:** \`${expression}\`
**Result:** \`${result}\`

ğŸ’¡ **Pro Tip:** I can handle basic arithmetic operations (+, -, *, /)

_For complex calculations, consider using specialized math tools._

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
      `;

      await this.bot.sendMessage(chatId, calculationMessage, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Error calculating:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t calculate that expression. Please check your input and try again.');
    }
  }

  private async handleDefine(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const word = match[1].trim();
    
    try {
      await this.bot.sendChatAction(chatId, 'typing');
      
      // Simulate dictionary lookup
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const definitions: { [key: string]: string } = {
        'artificial': 'Made by humans; not natural or real',
        'intelligence': 'The ability to acquire and apply knowledge and skills',
        'technology': 'The application of scientific knowledge for practical purposes',
        'innovation': 'The action or process of innovating; a new method or idea',
        'creativity': 'The use of imagination or original ideas to create something'
      };
      
      const definition = definitions[word.toLowerCase()] || `A definition for "${word}" - this would be fetched from a dictionary API in a full implementation.`;
      
      const definitionMessage = `
ğŸ“– *Dictionary Definition* ğŸ“–

**Word:** *${word}*

**Definition:**
${definition}

**Part of Speech:** Noun/Verb/Adjective (varies)

ğŸ’¡ **Example Usage:**
"The ${word} was impressive in its scope and application."

_For complete definitions, consider consulting comprehensive dictionaries._

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
      `;

      await this.bot.sendMessage(chatId, definitionMessage, { parse_mode: 'Markdown' });
      
    } catch (error) {
      console.error('Error defining word:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t find a definition for that word. Please try again.');
    }
  }

  private async handleAvatar(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const description = match[1].trim();
    
    try {
      await this.bot.sendChatAction(chatId, 'upload_photo');
      await this.bot.sendMessage(chatId, `ğŸ­ *Creating your avatar...*\n"${description}"\n\nPlease wait...`, { parse_mode: 'Markdown' });

      await new Promise(resolve => setTimeout(resolve, 3000));
      
      const avatarUrl = `https://picsum.photos/512/512?random=${Date.now()}`;
      
      await this.bot.sendPhoto(chatId, avatarUrl, {
        caption: `ğŸ­ *Your Custom Avatar*\nğŸ“ Description: "${description}"\n\n_Save this image as your profile picture!_`,
        parse_mode: 'Markdown'
      });

      this.updateUserUsage(chatId, 0, 120);
      
    } catch (error) {
      console.error('Error generating avatar:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t generate your avatar right now. Please try again later.');
    }
  }

  // Admin commands
  // PROJECT PHOENIX FEATURE HANDLERS

  private async handleProfile(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) {
      await this.bot.sendMessage(chatId, 'Please send /start first to initialize your profile.');
      return;
    }

    const levelProgress = this.calculateLevelProgress(user.totalPoints);
    const nextLevel = user.level + 1;
    const pointsToNext = (nextLevel * 100) - user.totalPoints;

    const profileMessage = `
ğŸ† *Your ShanxAi Profile* ğŸ†

ğŸ‘¤ **Personal Info:**
â€¢ Name: ${user.firstName || 'Anonymous'}
â€¢ Username: @${user.username || 'Not set'}
â€¢ Member since: ${user.joinDate.toDateString()}

ğŸ“Š **Progress & Stats:**
â€¢ ğŸ–ï¸ Level: ${user.level}
â€¢ â­ Total Points: ${user.totalPoints}
â€¢ ğŸ”¥ Daily Streak: ${user.dailyStreak} days
â€¢ ğŸ’¬ Messages Sent: ${user.messageCount}
â€¢ ğŸ† Achievements: ${user.achievements.length}/${Object.keys(this.ACHIEVEMENTS).length}

ğŸ“ˆ **Level Progress:**
${this.generateProgressBar(levelProgress, 10)} ${Math.round(levelProgress)}%
_${pointsToNext} points to Level ${nextLevel}_

ğŸ¤ **Referral Stats:**
â€¢ Your Code: \`${user.referralCode}\`
â€¢ Friends Referred: ${user.referrals.length}
â€¢ Referral Points Earned: ${user.referrals.length * this.REFERRAL_POINTS}

ğŸ“° **News Preferences:**
${user.newsTopics.map(topic => `â€¢ ${topic}`).join('\n')}

â° **Active Reminders:** ${user.activeReminders.filter(r => r.isActive).length}

_Keep chatting and using features to level up!_ ğŸš€
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸ† View Achievements', callback_data: 'view_achievements' },
          { text: 'ğŸ¤ Refer Friends', callback_data: 'refer_friends' }
        ],
        [
          { text: 'ğŸ“° News Settings', callback_data: 'news_settings' },
          { text: 'â° My Reminders', callback_data: 'view_reminders' }
        ],
        [
          { text: 'ğŸ”¥ Streak Info', callback_data: 'streak_info' },
          { text: 'ğŸ¯ Daily Challenge', callback_data: 'daily_challenge' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, profileMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending profile:', error);
    }
  }

  private async handleAchievements(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) return;

    const unlockedAchievements = user.achievements.map(id => 
      `âœ… ${this.ACHIEVEMENTS[id]?.name || 'Unknown'} - ${this.ACHIEVEMENTS[id]?.description || ''}`
    ).join('\n');

    const lockedAchievements = Object.keys(this.ACHIEVEMENTS)
      .filter(id => !user.achievements.includes(id))
      .map(id => `ğŸ”’ ${this.ACHIEVEMENTS[id].name} - ${this.ACHIEVEMENTS[id].description}`)
      .join('\n');

    const achievementMessage = `
ğŸ† *Your Achievements* ğŸ†

**Unlocked (${user.achievements.length}):**
${unlockedAchievements || '_No achievements yet - start chatting to unlock them!_'}

**Available to Unlock (${Object.keys(this.ACHIEVEMENTS).length - user.achievements.length}):**
${lockedAchievements}

ğŸ’¡ **Tips to Unlock More:**
â€¢ Chat daily to build your streak
â€¢ Refer friends with /refer
â€¢ Try different commands
â€¢ Generate images with /imagine
â€¢ Use various features regularly

_Each achievement gives you ${this.ACHIEVEMENT_POINTS} bonus points!_ â­
    `;

    try {
      await this.bot.sendMessage(chatId, achievementMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending achievements:', error);
    }
  }

  private async handleRefer(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) return;

    const referralMessage = `
ğŸ¤ *Invite Friends to ShanxAi* ğŸ¤

**Your Unique Referral Code:** \`${user.referralCode}\`

ğŸ“± **Share this link with friends:**
https://t.me/your_bot_username?start=${user.referralCode}

ğŸ **Referral Rewards:**
â€¢ **You get:** ${this.REFERRAL_POINTS} points per friend
â€¢ **They get:** Welcome bonus & premium features
â€¢ **Both get:** Exclusive achievements

ğŸ“Š **Your Referral Stats:**
â€¢ Friends Referred: ${user.referrals.length}
â€¢ Points Earned: ${user.referrals.length * this.REFERRAL_POINTS}
â€¢ Next Milestone: ${Math.max(0, 5 - user.referrals.length)} more for Influencer badge

ğŸŒŸ **Referral Benefits:**
â€¢ Unlock advanced AI features
â€¢ Increase daily message limits
â€¢ Get priority support
â€¢ Access to beta features

_Share ShanxAi with friends and grow together!_ ğŸš€
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸ“‹ Copy Referral Link', callback_data: `copy_referral_${user.referralCode}` }
        ],
        [
          { text: 'ğŸ“Š View Stats', callback_data: 'referral_stats' },
          { text: 'ğŸ Referral Rewards', callback_data: 'referral_rewards' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, referralMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending referral info:', error);
    }
  }

  private async handleRemind(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const reminderText = match[1].trim();
    
    try {
      // Parse natural language reminder
      const reminder = this.parseNaturalLanguageReminder(reminderText);
      
      if (!reminder.isValid) {
        await this.bot.sendMessage(chatId, `
âŒ **Couldn't understand the reminder format.**

ğŸ“ **Try these formats:**
â€¢ "Call mom in 2 hours"
â€¢ "Meeting tomorrow at 3pm"
â€¢ "Take medicine every day at 8am"
â€¢ "Workout in 30 minutes"
â€¢ "Pay bills on Friday"

ğŸ’¡ **Examples:**
/remind Call dentist tomorrow at 10am
/remind Buy groceries in 2 hours
/remind Team meeting every Monday at 9am
        `);
        return;
      }

      const user = this.users.get(chatId);
      if (!user) return;

      const reminderId = Date.now().toString();
      const newReminder = {
        id: reminderId,
        message: reminder.message,
        scheduledFor: reminder.date,
        isActive: true
      };

      user.activeReminders.push(newReminder);

      // Schedule the reminder
      this.scheduleReminder(chatId, newReminder);

      const confirmMessage = `
â° **Reminder Set Successfully!** â°

ğŸ“ **Message:** ${reminder.message}
ğŸ• **Scheduled for:** ${reminder.date.toLocaleString()}
ğŸ†” **ID:** \`${reminderId}\`

âœ… I'll remind you when the time comes!
Use /reminders to view all your active reminders.
      `;

      await this.bot.sendMessage(chatId, confirmMessage, { parse_mode: 'Markdown' });

    } catch (error) {
      console.error('Error setting reminder:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t set that reminder. Please try again with a different format.');
    }
  }

  private async handleNews(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) return;

    try {
      await this.bot.sendChatAction(chatId, 'typing');

      // Simulate fetching personalized news based on user topics
      const newsDigest = this.generatePersonalizedNews(user.newsTopics);

      const newsMessage = `
ğŸ“° *Your Personalized News Digest* ğŸ“°
_Updated: ${new Date().toLocaleString()}_

${newsDigest}

ğŸ“Š **News Preferences:**
${user.newsTopics.map(topic => `â€¢ #${topic}`).join(' ')}

ğŸ’¡ **Commands:**
â€¢ /news_subscribe [topic] - Add new topics
â€¢ /news_topics - See all available topics
â€¢ /news - Get fresh digest anytime

_Stay informed with ShanxAi!_ ğŸŒ
      `;

      const keyboard: InlineKeyboardMarkup = {
        inline_keyboard: [
          [
            { text: 'ğŸ”„ Refresh News', callback_data: 'refresh_news' },
            { text: 'âš™ï¸ Manage Topics', callback_data: 'manage_news_topics' }
          ],
          [
            { text: 'ğŸ“ˆ Trending', callback_data: 'trending_news' },
            { text: 'ğŸ” Search News', callback_data: 'search_news' }
          ]
        ]
      };

      await this.bot.sendMessage(chatId, newsMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });

    } catch (error) {
      console.error('Error fetching news:', error);
      await this.bot.sendMessage(chatId, 'âŒ Sorry, I couldn\'t fetch the news right now. Please try again later.');
    }
  }

  private async handleMoods(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;

    const moodMessage = `
ğŸ­ *Emotional Intelligence Center* ğŸ­

I can detect and respond to your emotions! Here's how:

**ğŸ˜Š Detected Emotions:**
â€¢ Happy/Excited â†’ Enthusiastic responses
â€¢ ğŸ˜” Sad/Down â†’ Empathetic & supportive
â€¢ ğŸ˜¤ Frustrated â†’ Calming & solution-focused
â€¢ ğŸ¤” Curious â†’ Detailed & informative
â€¢ ğŸ˜´ Tired â†’ Gentle & brief responses

**ğŸ¯ Personality Modes:**
â€¢ Professional - Business-focused responses
â€¢ Friendly - Casual & warm conversation
â€¢ Creative - Artistic & imaginative
â€¢ Technical - Detailed & precise
â€¢ Motivational - Encouraging & energizing

**ğŸ’¬ Try saying:**
"I'm feeling excited about my project!"
"I'm stressed about work"
"I'm curious about AI"

_I'll adapt my personality to match your mood!_ âœ¨
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: [
        [
          { text: 'ğŸ˜Š Happy Mode', callback_data: 'mood_happy' },
          { text: 'ğŸ¤” Curious Mode', callback_data: 'mood_curious' }
        ],
        [
          { text: 'ğŸ’¼ Professional', callback_data: 'mood_professional' },
          { text: 'ğŸ¨ Creative', callback_data: 'mood_creative' }
        ],
        [
          { text: 'ğŸš€ Motivational', callback_data: 'mood_motivational' },
          { text: 'ğŸ§˜ Calm Mode', callback_data: 'mood_calm' }
        ]
      ]
    };

    try {
      await this.bot.sendMessage(chatId, moodMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending mood info:', error);
    }
  }

  private async handleSuggestQuickReplies(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const history = this.chatHistories.get(chatId);
    
    // Generate contextual quick replies based on recent conversation
    const suggestions = this.generateQuickReplies(history);
    
    const suggestMessage = `
ğŸ’¡ *Smart Quick Replies* ğŸ’¡

Based on our conversation, here are some quick options:
    `;

    const keyboard: InlineKeyboardMarkup = {
      inline_keyboard: suggestions.map((suggestion, index) => [
        { text: suggestion, callback_data: `quick_reply_${index}` }
      ])
    };

    try {
      await this.bot.sendMessage(chatId, suggestMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } catch (error) {
      console.error('Error sending suggestions:', error);
    }
  }

  // Admin commands
  private async handleAdminUsers(msg: Message): Promise<void> {
    if (!this.bot || !this.isAdmin(msg.from?.id)) return;
    
    const chatId = msg.chat.id;
    const userList = Array.from(this.users.values())
      .sort((a, b) => b.lastActive.getTime() - a.lastActive.getTime())
      .slice(0, 20)
      .map((user, index) => {
        const status = this.activeUsers.has(user.id) ? 'ğŸŸ¢' : 'âš«';
        return `${index + 1}. ${status} ${user.firstName || 'Unknown'} (${user.id}) - ${user.messageCount} msgs`;
      })
      .join('\n');

    const adminMessage = `
ğŸ‘‘ *Admin: User List* ğŸ‘‘

**Total Users:** ${this.users.size}
**Active Now:** ${this.activeUsers.size}

**Recent Users (Top 20):**
${userList}

ğŸŸ¢ = Active | âš« = Inactive

Use /admin_history [userID] to view user chat history.
    `;

    try {
      await this.bot.sendMessage(chatId, adminMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending admin users:', error);
    }
  }

  private async handleAdminStats(msg: Message): Promise<void> {
    if (!this.bot || !this.isAdmin(msg.from?.id)) return;
    
    const chatId = msg.chat.id;
    
    const totalMessages = Array.from(this.users.values()).reduce((sum, user) => sum + user.messageCount, 0);
    const totalTokens = Array.from(this.users.values()).reduce((sum, user) => sum + user.tokenCount, 0);
    const avgMessagesPerUser = this.users.size > 0 ? Math.round(totalMessages / this.users.size) : 0;
    
    const adminMessage = `
ğŸ“Š *Admin: Bot Statistics* ğŸ“Š

**Users:**
ğŸ‘¥ Total Users: ${this.users.size}
ğŸŸ¢ Active Users: ${this.activeUsers.size}
ğŸ“ˆ New Users Today: ${this.getNewUsersToday()}

**Usage:**
ğŸ’¬ Total Messages: ${totalMessages}
ğŸ¯ Total Tokens: ${totalTokens}
ğŸ“Š Avg Messages/User: ${avgMessagesPerUser}

**System:**
âš¡ Bot Status: Online
ğŸ”„ Uptime: ${this.getUptime()}
ğŸ’¾ Memory Usage: ${this.getMemoryUsage()}

**Daily Limits:**
ğŸ“ Messages/Day: ${this.MAX_MESSAGES_PER_DAY}
ğŸ¯ Tokens/Day: ${this.MAX_TOKENS_PER_DAY}

// Created with love ğŸ©¶ by Denvil ğŸ§‘â€ğŸ’»
    `;

    try {
      await this.bot.sendMessage(chatId, adminMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending admin stats:', error);
    }
  }

  private async handleVoiceMessage(msg: Message): Promise<void> {
    if (!this.bot || !msg.voice) return;
    
    const chatId = msg.chat.id;
    
    try {
      await this.bot.sendMessage(chatId, 'ğŸ¤ *Voice message received!*\n\nTranscription: "This is a simulated transcription of your voice message. In a full implementation, this would use speech-to-text services."\n\nI can respond with text or occasionally with a voice message too! ğŸ”Š', { parse_mode: 'Markdown' });
      
      // Occasionally send a voice response (simulated)
      if (Math.random() < 0.2) { // 20% chance
        await this.bot.sendMessage(chatId, 'ğŸ”Š *Sending voice reply...* (Voice messages would be generated using text-to-speech services in the full implementation)');
      }
      
    } catch (error) {
      console.error('Error handling voice message:', error);
    }
  }

  private async handleUserMessage(msg: Message): Promise<void> {
    if (!this.bot || !msg.text || msg.text.startsWith('/')) return;
    
    const chatId = msg.chat.id;
    const userMessage = msg.text;
    const user = msg.from;
    
    if (!user) return;

    // Simple usage check
    if (!this.checkUsageLimits(user.id)) {
      await this.bot.sendMessage(chatId, 'âš ï¸ You\'ve reached your daily usage limit. Please try again tomorrow.');
      return;
    }

    this.activeUsers.add(chatId);
    this.initializeUser(user.id, user);

    try {
      // Show typing indicator
      await this.bot.sendChatAction(chatId, 'typing');

      // Get chat history for context
      const history = this.chatHistories.get(chatId);
      const chatHistory = history ? history.messages.slice(-5).map(msg => ({
        role: msg.isUser ? 'user' : 'assistant',
        content: msg.text
      })) : [];

      // Use the new cascading AI service
      const aiResponse = await this.aiService.generateResponse(userMessage, chatHistory);

      // Send response with website link
      const responseMessage = `${aiResponse}

ğŸŒ *Experience the full Nexus AI interface:*
${config.websiteUrl}`;

      const keyboard: InlineKeyboardMarkup = {
        inline_keyboard: [
          [
            { text: 'ğŸŒ Try Web Interface', url: config.websiteUrl }
          ]
        ]
      };

      await this.bot.sendMessage(chatId, responseMessage, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });

      // Update usage and save to history
      this.updateUserUsage(chatId, 1, 50);
      this.saveChatMessage(chatId, userMessage, aiResponse);

    } catch (error) {
      console.error('Error handling user message:', error);
      await this.bot.sendMessage(chatId, `âŒ I encountered an error processing your message. Please try again.

ğŸŒ *For a better experience, visit:*
${config.websiteUrl}`);
    }
  }

  private async handleCallbackQuery(query: any): Promise<void> {
    if (!this.bot || !query.data) return;

    const chatId = query.message.chat.id;
    const data = query.data;

    try {
      switch (data) {
        case 'start_chat':
          await this.bot.sendMessage(chatId, 'ğŸ’¬ Perfect! Just send me any message and I\'ll respond using advanced AI. What would you like to talk about?');
          break;
          
        case 'show_help':
          await this.handleHelp(query.message);
          break;
          
        case 'generate_image':
          await this.bot.sendMessage(chatId, 'ğŸ¨ To generate an image, use:\n/imagine [your description]\n\nExample: /imagine a futuristic city at sunset');
          break;
          
        default:
          await this.bot.sendMessage(chatId, 'ğŸ¤– I didn\'t understand that action. Try using the menu buttons or type a message!');
      }

      await this.bot.answerCallbackQuery(query.id);
    } catch (error) {
      console.error('Error handling callback query:', error);
      await this.bot.answerCallbackQuery(query.id, { text: 'Sorry, something went wrong!' });
    }
  }

  // Helper methods
  private initializeUser(userId: number, user: any): void {
    if (!this.users.has(userId)) {
      this.users.set(userId, {
        id: userId,
        username: user.username,
        firstName: user.first_name,
        lastName: user.last_name,
        messageCount: 0,
        tokenCount: 0,
        joinDate: new Date(),
        lastActive: new Date(),
        isBlocked: false
      });
    } else {
      const userData = this.users.get(userId)!;
      userData.lastActive = new Date();
      userData.username = user.username;
      userData.firstName = user.first_name;
      userData.lastName = user.last_name;
    }
  }

  private updateUserUsage(userId: number, messages: number, tokens: number): void {
    const user = this.users.get(userId);
    if (user) {
      user.messageCount += messages;
      user.tokenCount += tokens;
      user.lastActive = new Date();
    }
  }

  private checkUsageLimits(userId: number): boolean {
    const user = this.users.get(userId);
    if (!user) return true;

    // Reset daily counters if it's a new day
    const today = new Date().toDateString();
    const lastActiveDay = user.lastActive.toDateString();
    if (today !== lastActiveDay) {
      user.messageCount = 0;
      user.tokenCount = 0;
    }

    return user.messageCount < this.MAX_MESSAGES_PER_DAY && 
           user.tokenCount < this.MAX_TOKENS_PER_DAY;
  }

  private isAdmin(userId?: number): boolean {
    return userId === adminUID && adminUID !== 0;
  }

  private formatCodeSnippets(message: string): string {
    // Simple code detection patterns
    const codePatterns = [
      /```[\s\S]*?```/g, // Already formatted code blocks
      /`[^`]*`/g, // Inline code
      /function\s+\w+\s*\([^)]*\)\s*\{[\s\S]*?\}/g, // JavaScript functions
      /def\s+\w+\s*\([^)]*\):/g, // Python functions
      /class\s+\w+[\s\S]*?(?=\n\S|\n$)/g, // Class definitions
    ];

    let formatted = message;
    let hasCode = false;

    // Check if message contains code-like patterns
    const codeKeywords = ['function', 'def ', 'class ', 'import ', 'from ', 'const ', 'let ', 'var ', 'if ', 'for ', 'while '];
    const hasCodeKeywords = codeKeywords.some(keyword => message.toLowerCase().includes(keyword));
    
    const hasCodeChars = /[{}();]/.test(message) && message.length > 20;
    
    if (hasCodeKeywords || hasCodeChars) {
      hasCode = true;
      // Basic formatting - wrap in code block if not already formatted
      if (!message.includes('```') && !message.includes('`')) {
        formatted = `\`\`\`\n${message}\n\`\`\``;
      }
    }

    return hasCode ? formatted : message;
  }

  private enhanceResponseWithEmotion(response: string, emotion: string): string {
    const emotionalPrefixes: { [key: string]: string[] } = {
      happy: ["ğŸ‰ That's wonderful!", "âœ¨ I love your enthusiasm!", "ğŸŒŸ Great to hear!"],
      sad: ["ğŸ’™ I understand how you feel.", "ğŸ¤— I'm here to help.", "ğŸ’« Things will get better."],
      angry: ["ğŸ§˜ I hear your frustration.", "ğŸ’­ Let's work through this together.", "ğŸ¤ I'm here to help."],
      curious: ["ğŸ¤” Great question!", "ğŸ’¡ I love your curiosity!", "ğŸ¯ Let me explain..."],
      tired: ["ğŸ˜Œ Take it easy.", "ğŸ’¤ Rest is important.", "ğŸŒ™ Here's a gentle response:"],
      confused: ["ğŸ” Let me clarify that.", "ğŸ’« No worries, let's break it down.", "ğŸ¯ Here's a clearer explanation:"]
    };

    const emotionalSuffixes: { [key: string]: string[] } = {
      happy: ["Keep that positive energy! ğŸš€", "Stay awesome! âœ¨", "You're doing great! ğŸŒŸ"],
      sad: ["Take care of yourself. ğŸ’™", "You're not alone. ğŸ¤—", "Better days ahead. ğŸŒ…"],
      angry: ["Take a deep breath. ğŸ§˜", "One step at a time. ğŸš¶", "You've got this. ğŸ’ª"],
      curious: ["Keep exploring! ğŸ”", "Stay curious! ğŸŒŸ", "Learning never stops! ğŸ“š"],
      tired: ["Rest well. ğŸ˜Œ", "Take your time. â°", "Self-care first. ğŸŒ¸"],
      confused: ["Hope that helps! ğŸ’¡", "Feel free to ask more. ğŸ¤", "We'll figure it out. ğŸ¯"]
    };

    if (emotion === 'neutral') return response;

    const prefixes = emotionalPrefixes[emotion] || [];
    const suffixes = emotionalSuffixes[emotion] || [];

    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)] || '';
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)] || '';

    return `${prefix}\n\n${response}\n\n_${suffix}_`;
  }

  private checkMessageAchievements(userId: number): void {
    const user = this.users.get(userId);
    if (!user) return;

    // Check chatty achievement
    if (user.messageCount >= 100 && !user.achievements.includes('chatty')) {
      this.awardAchievement(userId, 'chatty');
    }
  }

  private saveChatMessage(userId: number, userMsg: string, botMsg: string): void {
    if (!this.chatHistories.has(userId)) {
      this.chatHistories.set(userId, {
        userId,
        messages: []
      });
    }

    const history = this.chatHistories.get(userId)!;
    history.messages.push(
      {
        id: Date.now().toString(),
        text: userMsg,
        isUser: true,
        timestamp: new Date()
      },
      {
        id: (Date.now() + 1).toString(),
        text: botMsg,
        isUser: false,
        timestamp: new Date()
      }
    );

    // Keep only last 50 messages
    if (history.messages.length > 50) {
      history.messages = history.messages.slice(-50);
    }
  }

  private async handleHistory(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const history = this.chatHistories.get(chatId);
    
    if (!history || history.messages.length === 0) {
      await this.bot.sendMessage(chatId, 'ğŸ“ No chat history found. Start a conversation to build your history!');
      return;
    }

    const recentMessages = history.messages.slice(-10);
    const historyText = recentMessages.map(msg => {
      const time = msg.timestamp.toLocaleTimeString();
      const sender = msg.isUser ? 'ğŸ‘¤ You' : 'ğŸ¤– ShanxAi';
      return `${time} - ${sender}: ${msg.text.substring(0, 100)}${msg.text.length > 100 ? '...' : ''}`;
    }).join('\n\n');

    const historyMessage = `ğŸ“ *Your Chat History* (Last 10 messages)\n\n${historyText}\n\n_Use /clear to clear your history_`;

    try {
      await this.bot.sendMessage(chatId, historyMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending history:', error);
    }
  }

  private async handleClear(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    this.chatHistories.delete(chatId);
    
    try {
      await this.bot.sendMessage(chatId, 'ğŸ—‘ï¸ *Chat history cleared!*\n\nYour conversation history has been deleted. Ready for a fresh start! ğŸŒŸ', { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error clearing history:', error);
    }
  }

  private async handleAdminHistory(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !this.isAdmin(msg.from?.id) || !match) return;
    
    const chatId = msg.chat.id;
    const targetUserId = parseInt(match[1]);
    const history = this.chatHistories.get(targetUserId);
    
    if (!history) {
      await this.bot.sendMessage(chatId, 'âŒ No chat history found for that user.');
      return;
    }

    const user = this.users.get(targetUserId);
    const userName = user ? (user.firstName || user.username || 'Unknown') : 'Unknown';
    
    const recentMessages = history.messages.slice(-15);
    const historyText = recentMessages.map(msg => {
      const time = msg.timestamp.toLocaleTimeString();
      const sender = msg.isUser ? 'ğŸ‘¤ User' : 'ğŸ¤– Bot';
      return `${time} - ${sender}: ${msg.text.substring(0, 150)}${msg.text.length > 150 ? '...' : ''}`;
    }).join('\n\n');

    const adminMessage = `ğŸ‘‘ *Admin: User Chat History*\n\n**User:** ${userName} (${targetUserId})\n\n${historyText}`;

    try {
      await this.bot.sendMessage(chatId, adminMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending admin history:', error);
    }
  }

  private async handleAdminBroadcast(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !this.isAdmin(msg.from?.id) || !match) return;
    
    const chatId = msg.chat.id;
    const broadcastMessage = match[1].trim();
    
    await this.bot.sendMessage(chatId, `ğŸ“¢ *Broadcasting message to ${this.users.size} users...*`, { parse_mode: 'Markdown' });
    
    let successCount = 0;
    let failCount = 0;

    for (const userId of this.users.keys()) {
      try {
        await this.bot.sendMessage(userId, `ğŸ“¢ *Admin Broadcast*\n\n${broadcastMessage}\n\n_This message was sent to all ShanxAi users._`, { parse_mode: 'Markdown' });
        successCount++;
        await new Promise(resolve => setTimeout(resolve, 100)); // Rate limiting
      } catch (error) {
        failCount++;
      }
    }

    await this.bot.sendMessage(chatId, `âœ… Broadcast complete!\n\nğŸ“Š **Results:**\nâ€¢ âœ… Successful: ${successCount}\nâ€¢ âŒ Failed: ${failCount}`, { parse_mode: 'Markdown' });
  }

  // Utility methods
  private getNewUsersToday(): number {
    const today = new Date().toDateString();
    return Array.from(this.users.values()).filter(user => 
      user.joinDate.toDateString() === today
    ).length;
  }

  private getUptime(): string {
    const uptime = process.uptime();
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);
    return `${hours}h ${minutes}m`;
  }

  private getMemoryUsage(): string {
    const used = process.memoryUsage();
    return `${Math.round(used.rss / 1024 / 1024)} MB`;
  }

  // PROJECT PHOENIX UTILITY FUNCTIONS

  private generateReferralCode(userId: number): string {
    const timestamp = Date.now().toString(36);
    const userIdHash = userId.toString(36);
    return `${userIdHash}${timestamp}`.slice(-8).toUpperCase();
  }

  private updateDailyStreak(userId: number): void {
    const user = this.users.get(userId);
    if (!user) return;

    const today = new Date().toDateString();
    const lastStreakDate = user.lastStreakDate?.toDateString();

    if (lastStreakDate !== today) {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (lastStreakDate === yesterday.toDateString()) {
        // Continue streak
        user.dailyStreak += 1;
        user.totalPoints += this.DAILY_STREAK_POINTS;
      } else if (!lastStreakDate || lastStreakDate < yesterday.toDateString()) {
        // Reset streak
        user.dailyStreak = 1;
        user.totalPoints += this.DAILY_STREAK_POINTS;
      }
      
      user.lastStreakDate = new Date();
      this.checkStreakAchievements(userId);
    }
  }

  private awardAchievement(userId: number, achievementId: string): void {
    const user = this.users.get(userId);
    if (!user || user.achievements.includes(achievementId)) return;

    user.achievements.push(achievementId);
    user.totalPoints += this.ACHIEVEMENT_POINTS;
    user.level = Math.floor(user.totalPoints / 100) + 1;

    // Send achievement notification
    this.sendAchievementNotification(userId, achievementId);
  }

  private async sendAchievementNotification(userId: number, achievementId: string): Promise<void> {
    if (!this.bot) return;
    
    const achievement = this.ACHIEVEMENTS[achievementId];
    if (!achievement) return;

    const message = `
ğŸ‰ *Achievement Unlocked!* ğŸ‰

${achievement.name}
_${achievement.description}_

ğŸ’° **Reward:** +${this.ACHIEVEMENT_POINTS} points
ğŸ–ï¸ **Total Achievements:** ${this.users.get(userId)?.achievements.length || 0}

_Keep up the great work!_ ğŸš€
    `;

    try {
      await this.bot.sendMessage(userId, message, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending achievement notification:', error);
    }
  }

  private checkStreakAchievements(userId: number): void {
    const user = this.users.get(userId);
    if (!user) return;

    const streak = user.dailyStreak;
    
    if (streak >= 30 && !user.achievements.includes('daily_streak_30')) {
      this.awardAchievement(userId, 'daily_streak_30');
    } else if (streak >= 7 && !user.achievements.includes('daily_streak_7')) {
      this.awardAchievement(userId, 'daily_streak_7');
    } else if (streak >= 3 && !user.achievements.includes('daily_streak_3')) {
      this.awardAchievement(userId, 'daily_streak_3');
    }
  }

  private calculateLevelProgress(totalPoints: number): number {
    const currentLevel = Math.floor(totalPoints / 100) + 1;
    const pointsInCurrentLevel = totalPoints % 100;
    return pointsInCurrentLevel;
  }

  private generateProgressBar(progress: number, length: number = 10): string {
    const filled = Math.round((progress / 100) * length);
    const empty = length - filled;
    return 'â–“'.repeat(filled) + 'â–‘'.repeat(empty);
  }

  private parseNaturalLanguageReminder(text: string): { isValid: boolean; message: string; date: Date } {
    const now = new Date();
    let message = text;
    let scheduledDate = new Date();
    let isValid = false;

    // Simple natural language parsing patterns
    const patterns = [
      // "in X minutes/hours"
      { regex: /(.+?)\s+in\s+(\d+)\s+(minute|minutes|hour|hours|min|mins|hr|hrs)/i, handler: (match: RegExpMatchArray) => {
        const amount = parseInt(match[2]);
        const unit = match[3].toLowerCase();
        message = match[1].trim();
        
        if (unit.startsWith('min')) {
          scheduledDate = new Date(now.getTime() + amount * 60 * 1000);
        } else {
          scheduledDate = new Date(now.getTime() + amount * 60 * 60 * 1000);
        }
        isValid = true;
      }},
      
      // "tomorrow at X"
      { regex: /(.+?)\s+tomorrow\s+at\s+(\d{1,2}):?(\d{2})?\s*(am|pm)?/i, handler: (match: RegExpMatchArray) => {
        message = match[1].trim();
        const hour = parseInt(match[2]);
        const minute = parseInt(match[3] || '0');
        const period = match[4]?.toLowerCase();
        
        scheduledDate = new Date(now);
        scheduledDate.setDate(scheduledDate.getDate() + 1);
        
        let finalHour = hour;
        if (period === 'pm' && hour !== 12) finalHour += 12;
        if (period === 'am' && hour === 12) finalHour = 0;
        
        scheduledDate.setHours(finalHour, minute, 0, 0);
        isValid = true;
      }},
      
      // "at X pm/am"
      { regex: /(.+?)\s+at\s+(\d{1,2}):?(\d{2})?\s*(am|pm)/i, handler: (match: RegExpMatchArray) => {
        message = match[1].trim();
        const hour = parseInt(match[2]);
        const minute = parseInt(match[3] || '0');
        const period = match[4].toLowerCase();
        
        scheduledDate = new Date(now);
        
        let finalHour = hour;
        if (period === 'pm' && hour !== 12) finalHour += 12;
        if (period === 'am' && hour === 12) finalHour = 0;
        
        scheduledDate.setHours(finalHour, minute, 0, 0);
        
        // If time has passed today, schedule for tomorrow
        if (scheduledDate <= now) {
          scheduledDate.setDate(scheduledDate.getDate() + 1);
        }
        isValid = true;
      }}
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern.regex);
      if (match) {
        pattern.handler(match);
        break;
      }
    }

    return { isValid, message, date: scheduledDate };
  }

  private scheduleReminder(userId: number, reminder: any): void {
    const delay = reminder.scheduledFor.getTime() - Date.now();
    
    if (delay > 0) {
      setTimeout(async () => {
        if (!this.bot) return;
        
        const user = this.users.get(userId);
        if (!user) return;
        
        // Check if reminder is still active
        const activeReminder = user.activeReminders.find(r => r.id === reminder.id && r.isActive);
        if (!activeReminder) return;
        
        const reminderMessage = `
â° *Reminder Alert!* â°

ğŸ“ **Message:** ${reminder.message}
ğŸ• **Scheduled for:** ${reminder.scheduledFor.toLocaleString()}

âœ… Reminder completed! Use /reminders to manage more.
        `;

        try {
          await this.bot.sendMessage(userId, reminderMessage, { parse_mode: 'Markdown' });
          
          // Mark reminder as completed
          activeReminder.isActive = false;
        } catch (error) {
          console.error('Error sending reminder:', error);
        }
      }, delay);
    }
  }

  private generatePersonalizedNews(topics: string[]): string {
    // Simulate personalized news generation
    const newsItems = [
      {
        category: 'technology',
        headline: 'AI Breakthrough: New Language Model Achieves Human-Level Performance',
        summary: 'Researchers announce significant advancement in artificial intelligence capabilities.'
      },
      {
        category: 'ai',
        headline: 'OpenAI Releases Enhanced ChatGPT with Improved Reasoning',
        summary: 'The latest update brings better logical reasoning and factual accuracy.'
      },
      {
        category: 'science',
        headline: 'Scientists Discover New Method for Carbon Capture',
        summary: 'Revolutionary technique could help combat climate change effectively.'
      },
      {
        category: 'business',
        headline: 'Tech Giants Report Strong Q4 Earnings',
        summary: 'Major technology companies exceed analyst expectations.'
      }
    ];

    return newsItems
      .filter(item => topics.includes(item.category))
      .slice(0, 3)
      .map((item, index) => `
**${index + 1}. ${item.headline}**
_${item.summary}_
ğŸ·ï¸ #${item.category}
      `).join('\n') || '_No news found for your selected topics._';
  }

  private generateQuickReplies(history?: ChatHistory): string[] {
    const defaultReplies = [
      "ğŸ‘ That's helpful!",
      "ğŸ¤” Tell me more",
      "âœ¨ Generate an image",
      "ğŸ“Š Show my stats",
      "ğŸ’¡ Suggest something",
      "ğŸ¯ What's next?"
    ];

    // If no history, return defaults
    if (!history || history.messages.length === 0) {
      return defaultReplies;
    }

    // Analyze recent messages for context-aware suggestions
    const recentMessages = history.messages.slice(-3);
    const contextualReplies: string[] = [];

    // Simple context detection
    const lastBotMessage = recentMessages.reverse().find(msg => !msg.isUser)?.text.toLowerCase() || '';
    
    if (lastBotMessage.includes('image') || lastBotMessage.includes('picture')) {
      contextualReplies.push("ğŸ¨ Generate another image");
    }
    
    if (lastBotMessage.includes('weather')) {
      contextualReplies.push("ğŸŒ¤ï¸ Check tomorrow's weather");
    }
    
    if (lastBotMessage.includes('calculate') || lastBotMessage.includes('math')) {
      contextualReplies.push("ğŸ§® Do another calculation");
    }

    // Combine contextual and default replies
    return [...contextualReplies, ...defaultReplies].slice(0, 6);
  }

  private detectEmotion(message: string): string {
    const emotions = {
      happy: ['happy', 'great', 'awesome', 'excited', 'love', 'ğŸ˜Š', 'ğŸ˜„', 'ğŸ‰', 'ğŸ¥³'],
      sad: ['sad', 'down', 'depressed', 'upset', 'ğŸ˜¢', 'ğŸ˜', 'ğŸ˜”'],
      angry: ['angry', 'mad', 'frustrated', 'annoyed', 'ğŸ˜ ', 'ğŸ˜¡', 'ğŸ¤¬'],
      curious: ['how', 'why', 'what', 'when', 'where', 'curious', 'ğŸ¤”'],
      tired: ['tired', 'exhausted', 'sleepy', 'ğŸ˜´', 'ğŸ˜ª'],
      confused: ['confused', 'unclear', 'lost', 'ğŸ˜•', 'ğŸ˜µ']
    };

    const lowerMessage = message.toLowerCase();
    
    for (const [emotion, keywords] of Object.entries(emotions)) {
      if (keywords.some(keyword => lowerMessage.includes(keyword))) {
        return emotion;
      }
    }
    
    return 'neutral';
  }

  private async handleStreak(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) return;

    const today = new Date().toDateString();
    const lastStreakDate = user.lastStreakDate?.toDateString();
    const isStreakActive = lastStreakDate === today || lastStreakDate === new Date(Date.now() - 24*60*60*1000).toDateString();

    const streakMessage = `
ğŸ”¥ *Your Daily Streak* ğŸ”¥

**Current Streak:** ${user.dailyStreak} day${user.dailyStreak !== 1 ? 's' : ''}
**Status:** ${isStreakActive ? 'ğŸŸ¢ Active' : 'ğŸ”´ Broken'}
**Last Activity:** ${user.lastStreakDate?.toDateString() || 'Never'}

**Streak Rewards:**
â€¢ ${user.dailyStreak} Ã— ${this.DAILY_STREAK_POINTS} = ${user.dailyStreak * this.DAILY_STREAK_POINTS} points earned

**Streak Milestones:**
${user.dailyStreak >= 3 ? 'âœ…' : 'ğŸ”²'} 3 days - "On Fire" achievement
${user.dailyStreak >= 7 ? 'âœ…' : 'ğŸ”²'} 7 days - "Weekly Warrior" achievement  
${user.dailyStreak >= 30 ? 'âœ…' : 'ğŸ”²'} 30 days - "Monthly Master" achievement

**ğŸ’¡ Streak Tips:**
â€¢ Send at least one message daily
â€¢ Use any command or feature
â€¢ Check /daily for fresh content
â€¢ Engage with the bot regularly

${isStreakActive ? '_Keep it up! Your streak is active!_ ğŸš€' : '_Chat with me today to start/continue your streak!_ ğŸ’ª'}
    `;

    try {
      await this.bot.sendMessage(chatId, streakMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending streak info:', error);
    }
  }

  private async handleLeaderboard(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;

    // Get top users by points
    const topUsers = Array.from(this.users.values())
      .sort((a, b) => b.totalPoints - a.totalPoints)
      .slice(0, 10);

    const currentUser = this.users.get(chatId);
    const currentUserRank = Array.from(this.users.values())
      .sort((a, b) => b.totalPoints - a.totalPoints)
      .findIndex(u => u.id === chatId) + 1;

    const leaderboardText = topUsers.map((user, index) => {
      const emoji = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
      const name = user.firstName || 'Anonymous';
      return `${emoji} ${name} - ${user.totalPoints} pts (L${user.level})`;
    }).join('\n');

    const leaderboardMessage = `
ğŸ† *ShanxAi Leaderboard* ğŸ†
_Top users by total points_

${leaderboardText}

${currentUser ? `
ğŸ“ **Your Position:** #${currentUserRank}
â­ **Your Points:** ${currentUser.totalPoints}
ğŸ–ï¸ **Your Level:** ${currentUser.level}
` : ''}

ğŸ’¡ **Earn Points By:**
â€¢ Daily messaging (+${this.MESSAGE_POINTS} per message)
â€¢ Maintaining streaks (+${this.DAILY_STREAK_POINTS} per day)
â€¢ Referring friends (+${this.REFERRAL_POINTS} per referral)
â€¢ Unlocking achievements (+${this.ACHIEVEMENT_POINTS} each)

_Keep climbing the ranks!_ ğŸš€
    `;

    try {
      await this.bot.sendMessage(chatId, leaderboardMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending leaderboard:', error);
    }
  }

  private async handleViewReminders(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);
    
    if (!user) return;

    const activeReminders = user.activeReminders.filter(r => r.isActive);
    
    if (activeReminders.length === 0) {
      await this.bot.sendMessage(chatId, `
â° *Your Reminders* â°

You have no active reminders.

ğŸ’¡ **Set a reminder with:**
/remind [your message]

**Examples:**
â€¢ /remind Call doctor tomorrow at 2pm
â€¢ /remind Team meeting in 30 minutes
â€¢ /remind Buy groceries after work
      `, { parse_mode: 'Markdown' });
      return;
    }

    const remindersList = activeReminders.map((reminder, index) => 
      `${index + 1}. **${reminder.message}**\n   ğŸ“… ${reminder.scheduledFor.toLocaleString()}\n   ğŸ†” \`${reminder.id}\``
    ).join('\n\n');

    const remindersMessage = `
â° *Your Active Reminders* â°

${remindersList}

ğŸ’¡ **Tips:**
â€¢ Reminders will be sent automatically
â€¢ Use /remind to set new ones
â€¢ Each reminder has a unique ID

_I'll make sure you don't forget!_ ğŸ¤–
    `;

    try {
      await this.bot.sendMessage(chatId, remindersMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending reminders:', error);
    }
  }

  private async handleNewsSubscribe(msg: Message, match: RegExpExecArray | null): Promise<void> {
    if (!this.bot || !match) return;
    
    const chatId = msg.chat.id;
    const topic = match[1].trim().toLowerCase();
    const user = this.users.get(chatId);
    
    if (!user) return;

    if (!this.NEWS_CATEGORIES.includes(topic)) {
      await this.bot.sendMessage(chatId, `
âŒ **Topic "${topic}" not available.**

ğŸ“° **Available topics:**
${this.NEWS_CATEGORIES.map(cat => `â€¢ ${cat}`).join('\n')}

ğŸ’¡ **Usage:** /news_subscribe technology
      `, { parse_mode: 'Markdown' });
      return;
    }

    if (user.newsTopics.includes(topic)) {
      await this.bot.sendMessage(chatId, `ğŸ“° You're already subscribed to **${topic}** news!`);
      return;
    }

    user.newsTopics.push(topic);
    
    await this.bot.sendMessage(chatId, `
âœ… **Subscribed to ${topic} news!**

ğŸ“° **Your topics:** ${user.newsTopics.join(', ')}

Use /news to get your personalized digest anytime!
    `, { parse_mode: 'Markdown' });
  }

  private async handleNewsTopics(msg: Message): Promise<void> {
    if (!this.bot) return;
    
    const chatId = msg.chat.id;
    const user = this.users.get(chatId);

    const topicsMessage = `
ğŸ“° *News Topics* ğŸ“°

**Available Categories:**
${this.NEWS_CATEGORIES.map(topic => `â€¢ ${topic}`).join('\n')}

${user ? `
**Your Subscriptions:**
${user.newsTopics.map(topic => `âœ… ${topic}`).join('\n')}
` : ''}

**Commands:**
â€¢ /news_subscribe [topic] - Subscribe to a topic
â€¢ /news - Get personalized news digest

**Example:** /news_subscribe technology
    `;

    try {
      await this.bot.sendMessage(chatId, topicsMessage, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error sending news topics:', error);
    }
  }

  private loadUserData(): void {
    // In a real implementation, this would load from database
    console.log('User data loaded from storage');
  }

  public isActive(): boolean {
    return this.bot !== null;
  }

  public getActiveUsers(): number {
    return this.activeUsers.size;
  }

  public getTotalUsers(): number {
    return this.users.size;
  }
}

// Also export the initialization function for backward compatibility
export const initializeBot = (aiService: AIService): TelegramBotService => {
  return new TelegramBotService(aiService);
};